type Token {
  id: ID! # token address
  pricePerETH: BigInt! # price of token per ETH
  pricePerUSD: BigInt! # price of token per USD
  lastUpdatedTimestamp: BigInt! # timestamp of last update
}

type LiquidityPool {
  id: ID! # pool address
  token0: Token!
  token1: Token!
  isStable: Boolean! # whether the pool is a stable AMM or a volatile AMM
  reserve0: BigInt!
  reserve1: BigInt!
  totalLiquidityETH: BigInt!
  totalLiquidityUSD: BigInt!
  totalVolume0: BigInt!
  totalVolume1: BigInt!
  totalVolumeUSD: BigInt!
  cumulativeFees0: BigInt!
  cumulativeFees1: BigInt!
  numberOfSwaps: BigInt!
  token0Price: BigInt! # price of token0 relative to token1
  token1Price: BigInt! # price of token1 relative to token0
  lastUpdatedTimestamp: BigInt! # timestamp of last update
  # users: [User!]! # users that have swapped in the pool
  usersExperimental: [LiquidityPoolUserMapping!]!
    @derivedFrom(field: "liquidityPool")
}

type LatestETHPrice {
  id: ID! # updated Timestamp
  price: BigInt! # In base 1e18
}

type StateStore {
  id: ID! # ID will always be "STORE"
  latestEthPrice: LatestETHPrice!
  poolsWithWhitelistedTokens: [LiquidityPool!]!
}

type User {
  id: ID! # user address
  numberOfSwaps: BigInt!
  totalSwapVolumeUSD: BigInt!
  lastUpdatedTimestamp: BigInt! # timestamp of last update
  # liquidityPools: [LiquidityPool!]!
  liquidityPoolsExperimental: [LiquidityPoolUserMapping!]!
    @derivedFrom(field: "user")
}

# mapping example
type LiquidityPoolUserMapping {
  id: ID! # concatenation of liquidityPool and user id
  liquidityPool: LiquidityPool!
  user: User!
}
